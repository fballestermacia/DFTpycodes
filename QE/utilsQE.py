import numpy as np
import matplotlib.pyplot as plt
import re #This module is for string manupilation, see its webpage

def read_filband(file='filband'):
    """
    Returns the kpoints and the electronic bands from the filband file generated by QE.
    """
    filelines = [line for line in open(file) if line.strip()]
    
    nbnd = int(filelines[0].split()[2].split(',')[0])
    nks = int(filelines[0].split()[4])
    
    kpointline = True
    for i, line in enumerate(filelines[1:]):
        if kpointline:
            try:
                kpoints=np.vstack([kpoints,np.array(line.split(), dtype='float')])
            except NameError:
                kpoints=np.array(np.array(line.split(), dtype='float'))
            
            bandval = []
            kpointline=False
        else:
            for dummy in line.split():
                bandval.append(float(dummy))
            if len(bandval) == nbnd:
                try:
                    bands=np.vstack([bands,np.array(bandval)])
                except NameError:
                    bands=np.array(bandval)
                kpointline=True
    
    return kpoints, bands


def read_bandsin(bandsinfile):
    """
    Returns the kpoints used form bands calculation, the number of high symmetry lines, 
    the high symmetry points, an array B of the basis vectors and the number of points in each high symmetry line.
    """
    filelines = [line for line in open(bandsinfile) if line.strip()]
    
    inKpoints=False
    inCellPar = False
    highsympoints = []
    pointsinline=[]
    
    for i, line in enumerate(filelines):
        if not inCellPar:
            if line.split()[0].upper() == 'CELL_PARAMETERS':
                inCellPar = True
                counter = 0
        else:
            try:
                B=np.vstack([B,np.array(line.split()[-3:],dtype=float)])
            except NameError:
                B=np.array(np.array(line.split()[-3:],dtype=float))
            counter += 1
            if counter == 3: 
                B = np.array(B)
                inCellPar=False
            
            
        
        if not inKpoints:
            if line.split()[0].upper() == 'K_POINTS':
                inKpoints = True
        else:
            if len(line.split()) == 1:
                nlines = int(line)
            else:
                try:
                    kpoints=np.vstack([kpoints,np.array(line.split()[0:3], dtype='float')])
                except NameError:
                    kpoints=np.array(np.array(line.split()[0:3], dtype='float'))
                pointsinline.append(int(line.split()[3]))
                hsp = line.split('!')[1].split('\n')[0]
                if hsp.upper() == 'GAMMA': hsp = '\\Gamma'
                highsympoints.append('${}$'.format(hsp))
                
                if len(highsympoints) == nlines: inKpoints=False
    
    return kpoints, nlines, highsympoints, B, pointsinline


def readPhononbandFreq(freqgpfile): #freqgpfile=SYSTEM.freq.gp

    data = np.loadtxt(freqgpfile)

    #nbands = data.shape[1] - 1
    qpoints = data[:, 0]
    bands = np.transpose(data)[1:,]

    return qpoints, bands


def readHighSymPointsPhonon(matdynfile, retKpoints=False):  #matdynfile=matdyn.in
    filelines = [line for line in open(matdynfile) if line.strip()]
    qbandform=False
    for i,fline in enumerate(filelines):
        fline = fline.strip()
        if fline.split()[0]=='readtau' and fline.split()[-1]=='.true.':
            continue #TODO: INCLUDE THE CASE WHERE ATOMIC POSITIONS ARE READ

        if fline.split()[0]=='q_in_band_form' and (fline.split()[-1]=='.true.'or fline.split()[-1]=='.true.,'):
            qbandform=True
            
        elif fline.split('=')[0]=='q_in_band_form' and (fline.split('=')[-1]=='.true.'or fline.split('=')[-1]=='.true.,'):
            qbandform=True
            

        if fline.split()[0]==r'/':
            if qbandform:
                start = i+1

            #TODO: make the case where qbandform=False
    
    npoints = int(filelines[start])
    labels = []
    if retKpoints: HSpoints = []
    positions = np.empty(npoints, dtype='int')
    counter = 0
    for i,kline in enumerate(filelines[start+1:]):
        dummylabel = str(kline.split('!')[-1].split()[0])
        if retKpoints:
            HSpoints.append([float(kline.split()[0]),float(kline.split()[1]),float(kline.split()[2])])
            
        if dummylabel[0].upper() == 'G':
            labels.append('$\\Gamma$')  
        else: labels.append('${}$'.format(dummylabel))
        positions[i] = counter
        counter += int(kline.split()[-2])
    
    if retKpoints:
        return labels, positions, HSpoints
    
    return labels, positions


def readEfermi(scfoutdile):
    """
    Returns the fermi energy from the scf.out file of QE.
    """
    filelines = [line for line in open(scfoutdile) if line.strip()]
    Efermi = None
    for line in filelines:
        if re.search('Fermi energy is', line):
            Efermi = float(line.split()[4])
            break
        elif re.search('highest occupied',line):
            if re.search('unoccupied', line):
                E1 = float(line.split()[6])
                E2 = float(line.split()[7])
                Efermi = (E2+E1)/2
                break
            else:
                Efermi = float(line.split()[4])
                break
    return Efermi


def readNElectrons(scfoutdile):
    """
    Returns the number of electrons from the scf.out file of QE.
    """
    filelines = [line for line in open(scfoutdile) if line.strip()]
    nelec = None
    for line in filelines:
        if re.search('number of electrons', line):
            nelec = int(float(line.split()[4]))
            break
    
    return nelec


def readTotalEnergy(scfoutdile):
    """
    Returns the total energy from the scf.out file of QE.
    """
    filelines = [line for line in open(scfoutdile) if line.strip()]
    toten = None
    for line in filelines[::-1]:
        if re.search('!', line):
            toten=float(line.split()[4])
            break
    return toten


def readNAtoms(scfoutdile):
    """
    Returns the number of atoms from the scf.out file of QE.
    """
    filelines = [line for line in open(scfoutdile) if line.strip()]
    natoms = None
    for line in filelines[::-1]:
        if re.search('number of atoms/cell', line):
            natoms=float(line.split()[4])
            break
    return natoms


def readTime(scfoutdile):
    """
    Returns the total runtime (in hours) from the scf.out file of QE.
    """
    filelines = [line for line in open(scfoutdile) if line.strip()]
    tottime = None
    for line in filelines[::-1]:
        if re.search("PWSCF.*WALL",line):
            time=line.split('CPU')[1].split('WALL')[0]
            h=0
            m=0
            s=0
            if 'h' in time:
                h=int(time.split('h')[0])
                time=time.split('h')[1]
            if 'm' in time:
                m=int(time.split('m')[0])
                time=time.split('m')[1]
            if 's' in time:
                s=float(time.split('s')[0])
            tottime=(s+60*(m+60*h))/3600
            break
    return tottime


def readRAM(scfoutdile):
    """
    Returns the total runtime (in hours) from the scf.out file of QE.
    """
    filelines = [line for line in open(scfoutdile) if line.strip()]
    totram = None
    for line in filelines[::-1]:
        if re.search("total.*RAM",line):
            if line.split()[6]=='MB':
                totram=str(float(line.split()[5])/1024)
            else:
                totram=line.split()[5]
            break
    return totram
    

def readForces(scfoutdile):
    """
    Returns the total force from the scf.out file of QE.
    """
    filelines = [line for line in open(scfoutdile) if line.strip()]
    totforce = None
    for line in filelines[::-1]:
        if re.search("Total.*force",line):
            totforce=line.split()[3]
            break
    return totforce


def orderedKgrid(kgrids):
    """
    Inputs a list of the folder names based on the KGrids (["4x4x4", "6x6x6",...])
    and returns the same list but ordered in ascending order of the number of kpoints in each grid.
    """
    dummyk = []
    for grid in kgrids:
        x,y,z = [int(i) for i in grid.split('x')]
        dummyk.append(x*y*z)
    outgrid = [ord for _, ord in sorted(zip(dummyk, kgrids))]
    return outgrid


def readcellvec(scffile):
    """
    Returns an array of vectors for the crystal and if present reciprocal axes of QE
    """
    cryst = []
    rec = []
    recempty=True
    incellpar = False
    filelines = [line for line in open(scffile) if line.strip]
    for line in filelines:
        try:
            line.split()[0]
        except IndexError:
            continue
        if line.split()[0].upper() == 'CELL_PARAMETERS':
            incellpar = True
            units = line.split()[-1]
            countvecs = 0
            continue
        if incellpar:
            cryst.append([float(line.split()[0]),float(line.split()[1]),float(line.split()[2])])
            countvecs += 1
            if countvecs==3:
                return np.array(cryst), units


        if line.split()[0] == 'a(1)' or line.split()[0] == 'a(2)' or line.split()[0] == 'a(3)':
            cryst.append([float(line.split()[3]),float(line.split()[4]),float(line.split()[5])])
        if line.split()[0] == 'b(1)' or line.split()[0] == 'b(2)' or line.split()[0] == 'b(3)':
            rec.append([float(line.split()[3]),float(line.split()[4]),float(line.split()[5])])
            recempty = False
    if recempty: return np.array(cryst)
    return np.array(cryst), np.array(rec)


def readCrystal(scffile):
    """
    Returns an array of elements, theirs positions and masses. 
    """
    names = []
    pos = []
    mass = []
    dummynames = []
    dummymass = []
    inspecies=False
    inpos = False
    filelines = [line for line in open(scffile) if line.strip]
    for line in filelines:
        try:
            line.split()[0]
        except IndexError:
            continue

        if line.split()[0].upper() == 'ATOMIC_SPECIES':
            inspecies = True
            continue
        
        if inspecies:
            if len(line.split()[0]) > 2:
                #print(line)
                break
            else:
                dummynames.append(line.split()[0])
                dummymass.append(float(line.split()[1]))
    
    for line in filelines:
        try:
            line.split()[0]
        except IndexError:
            continue

        if line.split()[0].upper() == 'ATOMIC_POSITIONS':
            inpos = True
            continue
        
        if inpos:
            if len(line.split()[0]) > 2:
                break
            names.append(line.split()[0])
            pos.append([float(line.split()[1]),float(line.split()[2]),float(line.split()[3])])
            
            mass.append(dummymass[dummynames.index(line.split()[0])])
                
    return names, np.array(pos), np.array(mass)


def readModesatKpoin(kpointvec, modesfile='matdyn.modes',scffile='scf.out'):
    """
    Returns an array of vector modes from the matdyn.modes file of QE at a given k-point
    """
    cryst,rec = readcellvec(scffile)
    
    kpoint = np.round(kpointvec[0]*rec[0]+kpointvec[1]*rec[1]+kpointvec[2]*rec[2],4)
    filelines = [line for line in open(modesfile) if line.strip]
    inmodes = False
    First = True
    modes = []
    for line in filelines:
        if not inmodes:
            
            try:
                if line.split()[0] == 'q':
                    if float(line.split()[2]) == kpoint[0] and float(line.split()[3]) == kpoint[1] and float(line.split()[4]) == kpoint[2]:
                        inmodes = True   
            except IndexError:
                continue         
        else:
            if line.split()[0][0] == 'd':
                break
            else:
                
                if line.split()[0] == 'freq':
                    if not First:
                        modes.append(modesatfreq)
                    modesatfreq = []
                    First = False
                elif line.split()[0][0] == '*': 
                    if not First: modes.append(modesatfreq)
                    continue    
                else:
                    vecs = line.split()[1:-1]
                    
                    dummymode =  np.array([float(vecs[0])+1j*float(vecs[1]),float(vecs[2])+1j*float(vecs[3]),float(vecs[4])+1j*float(vecs[5])])
                    modesatfreq.append(dummymode)
    
    return modes